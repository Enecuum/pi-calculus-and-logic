#!/usr/local/bin/enqpi --print-term


# Мультипликативная конюнкция (логическое умножение)
# все операнды одновременно доступны и присутствуют что даёт мультипликативный комутативный продукт элементов множества
# если хотябы один из операндов не удовлетворяет этому условию то логическая проверка не завершается успехом
! test() . a(b) , serializationLessThan8Bits(b) | isPrime(b) | isSquareRootOfPrimeMinusOne(b) ;


# Мультипликативная дизюнкция (логический выбор варианта среди всех элементов в выражении без исключения)
# все варианты одновременно доступны и находятся в выборе что даёт мультипликативный комутативный копродукт элементов множества
# если хотябы один из вариантов не находится в отдельно не влияющем а как либо привязанном выборе то оператор не является таковым




# cдесь выбранный вариант отменяет все остальные, при этом выборе выражение становится первым на применение и срабатывает отмена
# при этом не важно верными ли бы были отменённые варианты или нет
! test () , _a(?) . b<> . !_a<> | _a(?) . c<> . !_a<> | _a(?) . d<> . !_a<> ;


# оператор выбрать одно из независимо верных
# все выражения должны быть верны и только потом можно выбрать одно отменив другие
# при это если верность какого либо выражения зависит от другого то выбрать одно будет нельзя (тоесть веротность нарушить логику)

? { ? a<> | b<> | c<> , _d<> } . ? _d() . Fail ;


! test , _a { b<> } | _c { d<> } | _e { f<> } | _g(?) . _a() . _g<> | _g(?) . _c() . _g<> | _g(?) . _e() . _g<> ;





# оператор: если выбранное верно то любое выбранное из остальных должно быть неверным
# cдесь показано что верным может быть только один вариант из трёх а не более
# это значит что проверять надо все элементы без исключения
! test () , { ? a<> . d<> } | { ? b<> . d<> } | { ? c<> . d<> } | d() . d(?) . Fail

# оператор если выбранное верно то все остальные должны быть неверны





test {
! test() , a<>.c(d<*>) | a<>.c(e<*>) | a().c<3> | a().c<4> ;
! result1() , d<3> | e<4> ;
! result2() , d<4> | e<3> ;
}





