#!/usr/local/bin/enqpi --print-term


# Мультипликативная конюнкция (логическое умножение)
# тензорное произведение или декартово произведение или мультипликативный продукт 
# все операнды одновременно доступны и присутствуют что даёт мультипликативный комутативный продукт элементов множества
# если хотябы один из операндов не удовлетворяет этому условию то логическая проверка не завершается успехом
! _() . a(b) , serializationLessThan8Bits(b) | isPrime(b) | isSquareRootOfPrimeMinusOne(b) ;


# Мультипликативная дизюнкция (логический матч)
# выбор варианта среди всех элементов в выражении без исключения
# все варианты одновременно доступны и находятся в выборе что даёт мультипликативный комутативный копродукт элементов множества
# если хотябы один из вариантов не находится в отдельно не влияющем а как либо привязанном выборе то оператор не является таковым
# оператор: если выбранное верно то все остальные должны быть неверны причём глобально
# причём если было бы выбрано другое то вообще всё могло бы быть неверным как выбранный так и правильный
# быстрый отсев невозможен, для полной мультипликативности все варианты сначала считаются верными
# если один вариант был проверен на правильность и оказался неправильным то это никак не указывает на правильный вариант
# каждый вариант проверяется изолированно какбы в своей виртуальной машине в которой нет других вариантов
! _() , ? a<> . _d<> . ! _d() . Fail | ? b<> . _d<> . ! _d() . Fail | ? c<> . _d<> . ! _d() . Fail | _d() ;
! _() , a<> ⅋ b<> ⅋ c<> ;


# Аддитивная дизюнкция (логическое сложение)
# нужно найти хотябы один верный вариант и этого будет достаточно чтобы выражение было верным
# можно продолжать искать верные варианты и включать, таким образом добавляя их
# при этом время на поиск меньше так как можно предположить что другие выражение не верны и отложить их на потом
! _() , ? a<> . _d<> | ? b<> . _d<> | ? c<> . _d<> | _d() | ! _d() ;
! _() , a<> ⊕ b<> ⊕ c<> ; # синтаксический сахар


# Аддитивная конюнкция (логический магазин)
# все выражения верны и проверка не занимает много времени и ясна локально
# если рассматривать ситуацию глобально то если хотябы один вариант будет не верен то все выражение будет неверно
# если рассматривать адитивную дизюнкцию то нахождение хотябы одного верного варианта сокращяет время
# тут время сокращяется за счёт того что можно быстро провалить самое слабое звено не тратя время на всё выражение
! _() , ? _d<> | ! _g<?> . _d() , a<> . _g() | ! _f<?> . _d() , b<> . _f() | ! _e<?> . _d() , c<> . _e() ;
! _() , a<> & b<> & c<> ; # синтаксический сахар


# Аддитивный паттерн матчинг (логические весы)
! _() , a<> ⊡ b<> ⊡ c<> ;








