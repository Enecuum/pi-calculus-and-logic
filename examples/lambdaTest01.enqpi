#!/usr/local/bin/enqpi

# пример использования пространства имён
# название пространства и блок в фигурных скобках
# всё что внутри блока можно увидеть только из того же пространства имён
# тоесть из другого блока с тем же именем (пространство имён это блок имеющий имя)
демонстрационный лямбда сервер {

# используя префиксный экспоненциальный оператор Serv обозначенный восклицательным знаком
# сдесь задекларирован лямбда сервер, сервер это значит то что находится внутри оператора Serv
# циклически снова и снова повторяется нужное количество раз чтобы обслужить клиентов
# в данном случае оператор Serv закрывается точкой с запятой
! сервер ( запрос A )
. запрос A ( a ) | запрос A ( b ) | сервер сложения ( запрос B )
. запрос B < a > | запрос B < b > | запрос B ( c )
. запрос A < c > ;
# открывается оператор Serv
# далее оператор Wait который ждёт слушает канал "сервер" на входящие запросы
# запрос поступивший в канал "сервер" привязывается к локальному биндинг именованному каналу "запрос A"
# это значит что после оператора моноид (точка) можно им пользоваться, например поставить канал на приём сообщения
# канал "запрос А" получив сообщение которое является вcегда каналом и в данном случае служит аргументом "a"
# теперь готов выдать следующий аргумент "b", теперь есть два канала для использования "a" и "b"
# это аргументы которыми предстоит воспользоваться для расчёта суммы, суммирование это некомутативная операция
# это значит что использовать моноид (точку) было не обязательно и был использован оператор паралельных процессов (черта)

}

# сдесь используется пространство имён и задействуется функционал аббревиатурного поиска названий
ДемоЛямСерв {

# вызов к лямбда серверу без синтаксического сахара
сервер( лямбда ) . лямбда <2> . лямбда <3> . лямбда (результат) . print <результат> ;

# частое использование слова "лямбда" сокращено, передача каналов и биндинг идут друг за другом без доп синтакса
сервер( лямбда ) . лямбда <2> <3> (результат) . print <результат> ;

# передачи каналов можно использовать в одних скобках передачи
сервер( лямбда ) . лямбда <2 . 3> (результат) . print <результат> ;

# биндинг связка "результат" сокращена и print используется сразу в скобках биндинга
# звёздочка является локальной биндинг связкой внутри скобок и заменяет использование биндинга "результат"
сервер( лямбда ) . лямбда <2 . 3> ( print <*> ) ;

}
# закрытие блока пространства имён, теперь для вызовов к этому лямбда серверу придётся использовать пути

# пример вызова к лямбда серверу прибегая к обращению через пространство имён используя пути
# сдесь используется максимально краткий синтаксис для запроса к серверу
ДемоЛямСерв : сервер ( <2 . 3> ( print <*> ) ) ;

# синтаксис использования сервера сложения используется по разному
# в одном случае канал процедуры print вызывается снаружи и с биндингом канала "a"
# в другом случае внутри биндинга с использованием звёздочки как локальной биндинг привязки
# оба случая просто являются разным синтаксическим сахаром для пи исчисленим
# тоесть оба случая трансформируются в одну и ту же формулу
сервер сложения ( < 1 | 2 > ( a ) ) . print < a > ;
сервер сложения ( < 1 | 2 > ( print < * > ) ) ;

# синтаксический сахар "a < b + c >" автоматом трансформируется в "сервер сложения ( < b | c > ( a<*> ) )"
# теперь можно определить лямбда сервер с использованием этого сахара
! демо сервер №2 ( запрос A ) . запрос A ( a | b ) < a + b > ;

# степень некомутативный оператор поэтому сдесь корректно использовать некомутативный оператор моноида (точка)
! демо сервер №2 ( запрос A ) . запрос A ( a . b ) < a ^ b > ;

# биндинг канал "запрос А" можно сократить, получение аргументов и их сложение происходит внутри биндинга
! демо сервер №3 ( ( a | b ) < a + b > ) ;

















