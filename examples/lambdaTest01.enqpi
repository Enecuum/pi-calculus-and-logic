#!/usr/local/bin/enqpi

# пример использования пространства имён
# название пространства и блок в фигурных скобках
# всё что внутри блока можно увидеть только из того же пространства имён
# тоесть из другого блока с тем же именем ( пространство имён это блок имеющий имя )
демонстрационный лямбда сервер {

! сервер ( запрос A )
. запрос A ( a ) | запрос A ( b ) | сервер сложения ( запрос B )
. запрос B < a > | запрос B < b > | запрос B ( c )
. запрос A < c > ;

}

ДемоЛямСерв {

сервер( лямбда ) . лямбда <2> . лямбда <3> . лямбда (результат) . print <результат> ;

сервер( лямбда ) . лямбда <2> <3> (результат) . print <результат> ;

сервер( лямбда ) . лямбда <2 . 3> (результат) . print <результат> ;

сервер( лямбда ) . лямбда <2 . 3> ( print <*> ) ;

}

# пример вызова к лямбда серверу прибегая к обращению через пространство имён
# сдесь используется максимально краткий синтаксис для запроса к серверу
ДемоЛямСерв : сервер ( <2 . 3> ( print <*> ) ) ;

# синтаксис использования сервера сложения используется по разному
# в одном случае канал процедуры print вызывается снаружи и с биндингом канала "a"
# в другом случае внутри биндинга с использованием звёздочки как локальной биндинг привязки
# оба случая просто являются разным синтаксическим сахаром для пи исчисленим
# тоесть оба случая трансформируются в одну и ту же формулу
сервер сложения ( < 1 | 2 > ( a ) ) . print < a > ;
сервер сложения ( < 1 | 2 > ( print < * > ) ) ;

# синтаксический сахар "a < b + c >" автоматом трансформируется в "сервер сложения ( < b | c > ( a<*> ) )"
# теперь можно определить лямбда сервер с использованием этого сахара
! демо сервер №2 ( запрос A ) . запрос A ( a | b ) < a + b > ;

# биндинг канал "запрос А" можно сократить, получение аргументов и их сложение происходит внутри биндинга
! демо сервер №3 ( ( a | b ) < a + b > ) ;

















