#!/usr/local/bin/enqpi --print-term

#     ⊙ <*>  • ! & ⊗
# { S H(A.R)}N E L L
#  (?) < ? > ⊡ ? ⊕ ⅋

# Shared Noncommutative Exponential Linear Logic
# {a(?)}       ⊡•      ⊙    !?          ⊕& ⊗⅋


# Мультипликативная конюнкция (логическое умножение)
# тензорное произведение или декартово произведение или мультипликативный продукт 
# все операнды одновременно доступны и присутствуют что даёт мультипликативный комутативный продукт элементов множества
# если хотябы один из операндов не удовлетворяет этому условию то логическая проверка не завершается успехом
# любая канальная передача невозможна и биндинг изолирован так что логические выражения проверяются независимо
! _() , _a<_g> . b<> . _g() | _c<_h> . d<> . _h() | _e<_i> . f<> . i() | {_a|_c|_e}(_j|_k|_l) . _j<> . _k<> . _l<> ;
! _() . a(b) . serializationLessThan8Bits(b) ⊗ isPrime(b) ⊗ isSquareRootOfPrimeMinusOne(b) ; # пример синтаксического сахара


# Мультипликативная дизюнкция (логический матч)
# выбор варианта среди всех элементов в выражении без исключения
# все варианты одновременно доступны и находятся в выборе что даёт мультипликативный комутативный копродукт элементов множества
# если хотябы один из вариантов не находится в отдельно не влияющем а как либо привязанном выборе то оператор не является таковым
# оператор: если выбранное верно то все остальные должны быть неверны причём глобально
# причём если было бы выбрано другое то вообще всё могло бы быть неверным как выбранный так и правильный
# быстрый отсев невозможен, для полной мультипликативности все варианты сначала считаются верными
# если один вариант был проверен на правильность и оказался неправильным то это никак не указывает на правильный вариант
# каждый вариант проверяется изолированно какбы в своей виртуальной машине в которой нет других вариантов
| ? a<> . _d<> . ! _d() . Fail | ? b<> . _d<> . ! _d() . Fail | ? c<> . _d<> . ! _d() . Fail | _d() ;
! _() , a<> ⅋ b<> ⅋ c<> ; # синтаксический сахар



# Аддитивная дизюнкция (логическое сложение)
# нужно найти хотябы один верный вариант и этого будет достаточно чтобы выражение было верным
# можно продолжать искать верные варианты и включать, таким образом добавляя их
# при этом время на поиск меньше так как можно предположить что другие выражение не верны и отложить их на потом
! _() , _a1<> . a<> . _a2<> ⊗ _b1<> . b<> . _b2<> ⊗ _c1<> . c<> . _c2<>
| ? _a1<> . _d<> | ? _b1<> . _d<> | ? _c1<> . _d<> | _d() | ! _d() ;
# синтаксический сахар
! _() , a<> ⊕ b<> ⊕ c<> ;


# Аддитивная конюнкция (логический магазин)
# все выражения верны и проверка не занимает много времени и ясна локально
# если рассматривать ситуацию глобально то если хотябы один вариант будет не верен то все выражение будет неверно
# если рассматривать адитивную дизюнкцию то нахождение хотябы одного верного варианта сокращяет время
# тут время сокращяется за счёт того что можно быстро провалить самое слабое звено не тратя время на всё выражение
! _() , ? _d<> | ! _g<?> . _d() , a<> . _g() | ! _f<?> . _d() , b<> . _f() | ! _e<?> . _d() , c<> . _e() ;
! _() , a<> & b<> & c<> ; # синтаксический сахар


# Аддитивный паттерн матчинг (логические весы)
# первые элементы проходят проверку с левой стороной и если проверка неудаётся то элементы отменяются и проверка идёт дальше
# последние элементы проходят проверку с правой стороной по аналогичному принципу но с учётом специфики стороны
! _() , a<> ⊡ b<> ⊡ c<> ;


# Экспоненциальный контроль тюринг циклов (логический газ)
# возможен рекурсивный биндинг и отправка каналов (тюринг полнота в потенциале) но только в порядке контроля и учёте циклов
# учитывается как рост вариантов так и рост рекурсивного повторения процессов
# оператор некомутативный асоциативный и аргументы задают контроль потребления газа (марок газа) и приоритет цикличности
# количество рекурсивного повторения первых (приоритетных) процессов влияет на количество разрешенных циклов у последующих
# соответственно нужда в циклах у последующих процессов будут требовать отмотки счётчика у первых процессов
# если считать с другого конца то последний аргумент задаёт приоритетное влияние по количеству перебранных вариантов
# сложные контракты могут требовать большего перебора вариантов что также контролируется и влияет на циклы в выражении
! _() , a<> ⊙ b<> ⊙ c<> ;

# Логический шаринг поддержка Direct Acyclic Graph и Direct Acyclic Hypergraph






